#!/usr/bin/env bash

prompt="> "
save="tasks.txt"
swap="tasks.txt.swp"

# indicator marks
CLOSED='x'
OPEN=' '
SEMICLOSED='-'
ACTIVE='\*'

# regexes used to maintain task list
instruction='[a-zA-Z0-9, -]+'
taskname='[a-zA-Z0-9,-]+'
progress='\([0-9]+ of [0-9]+ m\)'
progress_grouped='\(([0-9]+) of ([0-9]+) m\)'
timestamp='\{[0-9]+\}'
timestamp_grouped='\{([0-9]+)\}'
metadata="$progress $timestamp"
indicator='.'

# ---------------------------------------------------------------------------

# check that string $1 matches regex $2
function verify() {
  check=$(echo $1 | sed -E -e "s/$2//")
  if [ "$check" != "" ]; then
    echo "The string '$1' is invalid (does not match the regex '$2')."
    (exit 1)
  else
    (exit 0)
  fi
}

# check that the number $1 (given) is equal to $2 (expected).
# print $3 indicating proper usage if not
function verify_usage() {
  if [ "$1" -ne "$2" ]; then
    echo "Expected $2 argument(s) but got $1."
    echo "Usage: $3"
    (exit 1)
  else
    (exit 0) 
  fi
}

# apply sed command $1 to the task list
function sedit() {
  cat "$save" | sed -E -e "$1" > "$swap"
  cp "$swap" "$save"
}

# ---------------------------------------------------------------------------

# get state of task $1
function state() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*($indicator) $1 $progress $timestamp.*/\\1/"
}

# get timestamp of task $1
function timestamp() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*$indicator $1 $progress $timestamp_grouped.*/\\1/"
}

# get time spent (in minutes) on task $1 so far
function spent() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*$indicator $1 $progress_grouped $timestamp_grouped.*/\\1/"
}

# get time allocated (in minutes) for task $1
function allocated() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*$indicator $1 $progress_grouped $timestamp_grouped.*/\\2/"
}

# ---------------------------------------------------------------------------

# set timestamp and progress of task $1 if it's active
function update_task() {
  stat=$(state $1)
  if [ "\\$stat" != "$ACTIVE" ]; then
    return
  fi
  old_stamp=$(timestamp "$1")
  old_spent=$(spent "$1")
  new_stamp=$(date +%s)
  new_spent=$(echo "($old_spent*60 + ($new_stamp - $old_stamp)) / 60" | bc)
  error=$(echo "($new_stamp - $old_stamp) % 60" | bc)
  new_stamp=$(echo "$new_stamp - $error" | bc)
  sedit "s/($indicator $1) $progress_grouped $timestamp/\\1 ($new_spent of \\3 m) {$new_stamp}/g"
}

# set timestamp of task $1 to now
function update_stamp() {
  new_stamp=$(date +%s)
  sedit "s/($indicator $1 $progress) $timestamp/\\1 {$new_stamp}/g"
}

# update timestamps and progresses of all active tasks
function update() {
  printf "" > "$swap"
  while IFS="" read -r line; do
    task=$(echo "$line" | sed -E -e "s/$indicator ($taskname) $metadata/\\1/") 
    update_task "$task"
  done < "$save"
}

# mark a task with name $1 as $2
function mark() {
  sedit "s/$indicator ($1 $metadata)/$2 \\1/g"
}

# ---------------------------------------------------------------------------

# list all tasks
function list() {
  cat "tasks.txt" | sed -E -e "s/ $timestamp//g"
}

# add a task with name $1 and time allocation $2 (in minutes)
function add() {
  if verify "$1" "$taskname"; then
    echo "$OPEN $1 (0 of $2 m) {$(date +%s)}" >> "$save"
  fi
}

# remove task with name $1
function remove() {
  sedit "/$indicator $1 $metadata/d"
}

# mark task with name $1 as closed
function close() {
  mark "$1" $CLOSED
}

# mark active task as semi-closed
function idle() {
  sedit "s/$ACTIVE ($taskname $metadata)/$SEMICLOSED \\1/g"
}

# set task with name $1 to be active
function go() {
  idle
  update_stamp "$1"
  mark "$1" $ACTIVE
}

# sort task list
function sort_list() {
  printf "" > "$swap"

  # sort by status, then alphanumerically
  grep -E "^$CLOSED" "$save" | sort >> "$swap"
  grep -E "^$SEMICLOSED" "$save" | sort >> "$swap"
  grep -E "^$OPEN" "$save" | sort >> "$swap"
  grep -E "^$ACTIVE" "$save" | sort >> "$swap"
  cp "$swap" "$save"
}

# evaluate a command $1 with arguments $2 $3 ...
function evaluate() {
  argc=$(echo $#-1 | bc)
  case "$1" in
  l|list)
    if verify_usage $argc 0 "list"; then
      list
    fi
    ;;
  a|add)
    if verify_usage $argc 2 "add name minutes"; then
      add "$2" "$3"
    fi
    ;;
  r|remove)
    if verify_usage $argc 1 "remove name"; then
      remove "$2"
    fi
    ;;
  c|close)
    if verify_usage $argc 1 "close name"; then
      close "$2"
    fi
    ;;
  i|idle)
    if verify_usage $argc 0 "idle"; then
      idle
    fi
    ;;
  s|sort)
    if verify_usage $argc 0 "sort"; then
      sort_list
    fi
    ;;
  g|go)
    if verify_usage $argc 1 "go name"; then
      go "$2"
    fi
    ;;
  cl|clear)
    if verify_usage $argc 0 "clear"; then
      clear
    fi
    ;;
  h|help)
    echo "Commands:"
    echo "  l, list: list all tasks"
    echo "  a, add: add task to list"
    echo "  r, remove: remove task from list"
    echo "  c, close: mark task as closed"
    echo "  i, idle: pause active task"
    echo "  s, sort: sort task list"
    echo "  g, go: set new active task"
    echo "  cl, clear: clear screen"
    echo "  h, help: show this text"
    echo "  q, quit: quit"
    echo "idle, sort, clear, and exit take no arguments."
    echo "Enter any of the other commands without any arguments for usage details."
    ;;
  q|quit)
    if verify_usage $argc 0 "quit"; then
      exit
    fi
    ;;
  '')
    ;;
  *)
    echo "Unknown command '$1'"
    ;;
  esac
}

# ---------------------------------------------------------------------------

while : ; do
  read -p "$prompt" cmd

  # eval is used to tokenize $cmd
  if verify "$cmd" "$instruction"; then
    update
    eval 'evaluate '$cmd
  fi
done

