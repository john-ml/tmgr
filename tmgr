#!/usr/bin/env bash

prompt="> "
branch="â””"
save="tasks.txt"
swap="tasks.txt.swp"

# indicator marks
CLOSED='x'
OPEN=' '
SEMICLOSED='-'
ACTIVE='\*'

# regexes used to maintain task list
instruction='[a-zA-Z0-9, -]+'
indicator='.'
branches=" *$branch?"
prefix="$indicator $branches"
taskname='[a-zA-Z0-9,-]+'
progress='\([0-9]+ of [0-9]+ min\)'
progress_grouped='\(([0-9]+) of ([0-9]+) min\)'
timestamp='\{[0-9]+\}'
timestamp_grouped='\{([0-9]+)\}'
metadata="$progress $timestamp"
parent="$indicator $taskname $metadata"
child="$indicator  *$branch$taskname $metadata"

# ---------------------------------------------------------------------------

# check that string $1 matches regex $2
function verify() {
  check=$(echo $1 | sed -E -e "s/$2//")
  if [ "$check" != "" ]; then
    echo "The string '$1' is invalid (does not match the regex '$2')."
    (exit 1)
  else
    (exit 0)
  fi
}

# check that the number $1 (given) is equal to $2 (expected).
# print $3 indicating proper usage if not
function verify_usage() {
  if [ "$1" -ne "$2" ]; then
    echo "Expected $2 argument(s) but got $1."
    echo "Usage: $3"
    (exit 1)
  else
    (exit 0) 
  fi
}

# apply sed command $1 to the task list
function sedit() {
  cat "$save" | sed -E -e "$1" > "$swap"
  cp "$swap" "$save"
}

# ---------------------------------------------------------------------------

# get state of task $1
function state() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*($indicator) $branches$1 $progress $timestamp.*/\\1/"
}

# get timestamp of task $1
function timestamp() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*$prefix$1 $progress $timestamp_grouped.*/\\1/"
}

# get time spent (in minutes) on task $1 so far
function spent() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*$prefix$1 $progress_grouped $timestamp_grouped.*/\\1/"
}

# get time allocated (in minutes) for task $1
function allocated() {
  cat "$save" | tr '\n' ';' | \
    sed -E -e "s/.*$prefix$1 $progress_grouped $timestamp_grouped.*/\\2/"
}

# ---------------------------------------------------------------------------

# set timestamp and progress of task $1 if it's active
function update_task() {
  stat=$(state $1)
  if [ "\\$stat" != "$ACTIVE" ]; then
    return
  fi
  old_stamp=$(timestamp "$1")
  old_spent=$(spent "$1")
  new_stamp=$(date +%s)
  new_spent=$(echo "($old_spent*60 + ($new_stamp - $old_stamp)) / 60" | bc)
  error=$(echo "($new_stamp - $old_stamp) % 60" | bc)
  new_stamp=$(echo "$new_stamp - $error" | bc)
  sedit "s/($prefix$1) $progress_grouped $timestamp/\\1 ($new_spent of \\3 min) {$new_stamp}/g"
}

# set timestamp of task $1 to now
function update_stamp() {
  new_stamp=$(date +%s)
  sedit "s/($prefix$1 $progress) $timestamp/\\1 {$new_stamp}/g"
}

# update timestamps and progresses of all active tasks
function update() {
  printf "" > "$swap"
  while IFS="" read -r line; do
    task=$(echo "$line" | sed -E -e "s/$prefix($taskname) $metadata/\\1/") 
    update_task "$task"
  done < "$save"
}

# mark a task with name $1 as $2
function mark() {
  sedit "s/$indicator ($branches$1 $metadata)/$2 \\1/g"
}

# collapse all tasks and subtasks onto a single line (so one task tree per line)
function collapse() {
  echo -e "$(cat "$save" | tr '\n' ';' | \
    sed -E -e "s/($parent(;$child)*);/\\1\\\\n/g")" > "$swap"
  cp "$swap" "$save"
}

# expand collapsed subtasks onto their own lines
function expand() {
  echo -e "$(cat "$save" | tr ';' '\n')" > "$swap"
  cp "$swap" "$save"
}

# ---------------------------------------------------------------------------

# list all tasks
function list() {
  cat "tasks.txt" | sed -E -e "s/ $timestamp//g"
}

# add a task with name $1 and time allocation $2 (in minutes)
function add() {
  if verify "$1" "$taskname"; then
    if verify "$2" "[0-9]+"; then
      echo "$OPEN $1 (0 of $2 min) {$(date +%s)}" >> "$save"
    fi
  fi
}

# remove task with name $1 and any subtasks
function remove() {
  if verify "$1" "$taskname"; then
    collapse
    sedit "/$prefix$1 $metadata.*/d"
    expand
  fi
}

# adjust task $1 to take $2 minutes
function realloc() {
  if verify "$1" "$taskname"; then
    if verify "$2" "[0-9]+"; then
      sedit "s/($prefix$1) $progress_grouped ($timestamp)/\\1 (\\2 of $2 min) \\4/g"
    fi
  fi
}

# rename task $1 to $2
function rename() {
  if verify "$1" "$taskname"; then
    if verify "$2" "$taskname"; then 
      sedit "s/($prefix)$1 ($metadata)/\\1 $2 \\2/g"
    fi
  fi
}

# create subtask $2 of task $1 to take $3 minutes
function branch() {
  if verify "$1" "$taskname"; then
    if verify "$2" "$taskname"; then 
      if verify "$3" "[0-9]+"; then
        indent=$(cat "$save" | tr -d '\n' | sed -E -e "s/.*$indicator ($branches)$1 $metadata.*/\\1/" | sed -E -e "s/ |$branch/ /")
        sedit "s/($prefix$1 $metadata)/\\1\n  $indent$branch$2 (0 of $3 min) {$(date +%s)}/g"
      fi
    fi
  fi
}


# mark task with name $1 as closed
function close() {
  if verify "$1" "$taskname"; then
    mark "$1" $CLOSED
  fi
}

# mark active task as semi-closed
function idle() {
  sedit "s/$ACTIVE ($branches$taskname $metadata)/$SEMICLOSED \\1/g"
}

# set task with name $1 to be active
function go() {
  if verify "$1" "$taskname"; then
    idle
    update_stamp "$1"
    mark "$1" $ACTIVE
  fi
}

# sort task list
function sort_list() {
  # preserve subtrees
  collapse

  # sort by status, then alphanumerically
  printf "" > "$swap"
  grep -E "^$CLOSED" "$save" | sort >> "$swap"
  grep -E "^$SEMICLOSED" "$save" | sort >> "$swap"
  grep -E "^$OPEN" "$save" | sort >> "$swap"
  grep -E "^$ACTIVE" "$save" | sort >> "$swap"
  cp "$swap" "$save"

  # restore subtrees
  expand
}

# evaluate a command $1 with arguments $2 $3 ...
function evaluate() {
  argc=$(echo $#-1 | bc)
  case "$1" in
  l|list)
    if verify_usage $argc 0 "list"; then
      list
    fi
    ;;
  a|add)
    if verify_usage $argc 2 "add name minutes"; then
      add "$2" "$3"
    fi
    ;;
  r|remove)
    if verify_usage $argc 1 "remove name"; then
      remove "$2"
    fi
    ;;
  re|realloc)
    if verify_usage $argc 2 "realloc name minutes"; then
      realloc "$2" "$3"
    fi
    ;;
  mv|rename)
    if verify_usage $argc 2 "rename old new"; then
      rename "$2" "$3"
    fi
    ;;
  b|branch)
    if verify_usage $argc 3 "branch parent child minutes"; then
      branch "$2" "$3" "$4"
    fi
    ;;
  c|close)
    if verify_usage $argc 1 "close name"; then
      close "$2"
    fi
    ;;
  i|idle)
    if verify_usage $argc 0 "idle"; then
      idle
    fi
    ;;
  s|sort)
    if verify_usage $argc 0 "sort"; then
      sort_list
    fi
    ;;
  g|go)
    if verify_usage $argc 1 "go name"; then
      go "$2"
    fi
    ;;
  cl|clear)
    if verify_usage $argc 0 "clear"; then
      clear
    fi
    ;;
  h|help)
    echo "Commands:"
    echo "  l, list: list all tasks"
    echo "  a, add: add task to list"
    echo "  r, remove: remove task from list"
    echo "  re, realloc: adjust estimated task duration"
    echo "  mv, rename: rename a task"
    echo "  b, branch: create a subtask"
    echo "  c, close: mark task as closed"
    echo "  i, idle: pause active task"
    echo "  s, sort: sort task list"
    echo "  g, go: set new active task"
    echo "  cl, clear: clear screen"
    echo "  h, help: show this text"
    echo "  q, quit: quit"
    echo "idle, sort, clear, and exit take no arguments."
    echo "Enter any of the other commands without any arguments for usage details."
    ;;
  q|quit)
    if verify_usage $argc 0 "quit"; then
      exit
    fi
    ;;
  '')
    ;;
  *)
    echo "Unknown command '$1'"
    ;;
  esac
}

# ---------------------------------------------------------------------------

while : ; do
  read -p "$prompt" cmd

  if verify "$cmd" "$instruction"; then
    update
    # eval is used to tokenize $cmd
    eval 'evaluate '$cmd
  fi
done

